"use strict";(self.webpackChunkthis_is_angular_guides=self.webpackChunkthis_is_angular_guides||[]).push([[8533],{2681:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return c}});var i=n(3117),o=n(102),a=(n(7294),n(3905)),r=["components"],l={contributors:"Nate Lapinski"},s="Routing in Angular applications",u={unversionedId:"fundamentals/routing-in-angular-applications",id:"fundamentals/routing-in-angular-applications",title:"Routing in Angular applications",description:"Suggested topics",source:"@site/docs/fundamentals/routing-in-angular-applications.md",sourceDirName:"fundamentals",slug:"/fundamentals/routing-in-angular-applications",permalink:"/angular-guides/docs/fundamentals/routing-in-angular-applications",draft:!1,editUrl:"https://github.com/this-is-angular/angular-guides/edit/main/docs/fundamentals/routing-in-angular-applications.md",tags:[],version:"current",frontMatter:{contributors:"Nate Lapinski"},sidebar:"guidesSidebar",previous:{title:"How change detection works in Angular projects",permalink:"/angular-guides/docs/fundamentals/how-change-detection-works-in-angular-projects"},next:{title:"The Angular HttpClient and interceptors",permalink:"/angular-guides/docs/fundamentals/the-angular-httpclient-and-interceptors"}},p={},c=[{value:"Suggested topics",id:"suggested-topics",level:2},{value:"Server-Side Routing and Client-Side Routing",id:"server-side-routing-and-client-side-routing",level:2},{value:"Server-Side Routing",id:"server-side-routing",level:3},{value:"Client-Side Routing (Angular)",id:"client-side-routing-angular",level:3},{value:"Defining Application Routes",id:"defining-application-routes",level:2},{value:"Static Routing, and the Route Configuration Object",id:"static-routing-and-the-route-configuration-object",level:3},{value:"Mental Model 1: A Tree of Components",id:"mental-model-1-a-tree-of-components",level:3},{value:"The Navigation Cycle",id:"the-navigation-cycle",level:2},{value:"The role of the <code>&lt;router-outlet&gt;</code> directive",id:"the-role-of-the-router-outlet-directive",level:2},{value:"Route configuration",id:"route-configuration",level:2},{value:"Route guards",id:"route-guards",level:2},{value:"Route resolvers",id:"route-resolvers",level:2},{value:"Router events",id:"router-events",level:2},{value:"Lazy loading",id:"lazy-loading",level:2},{value:"What is static routing? How does it differ from dynamic routing?",id:"what-is-static-routing-how-does-it-differ-from-dynamic-routing",level:3},{value:"The Role of RxJS in Routing",id:"the-role-of-rxjs-in-routing",level:3}],d={toc:c};function h(e){var t=e.components,n=(0,o.Z)(e,r);return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"routing-in-angular-applications"},"Routing in Angular applications"),(0,a.kt)("h2",{id:"suggested-topics"},"Suggested topics"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Navigation"),(0,a.kt)("li",{parentName:"ul"},"Route guards"),(0,a.kt)("li",{parentName:"ul"},"Route resolvers"),(0,a.kt)("li",{parentName:"ul"},"Router events"),(0,a.kt)("li",{parentName:"ul"},"Lazy-loading"),(0,a.kt)("li",{parentName:"ul"},"Route configuration")),(0,a.kt)("h1",{id:"routing"},"Routing"),(0,a.kt)("p",null,"Routing is what enables users to navigate from page to page inside of an Angular application. It is a surpisingly deep subject, especially in Angular. This guide will give you a comprehensive view of client-side routing in Angular, as well as some deeper insights into how the framework implements this concept. "),(0,a.kt)("p",null,"In its simplest form, the router enables navigation from page to page, usually updating the browser's location along the way. But Angular's router module is responsible for so much more. It enables lazy loading of modules, enforces route guards, and improves performance, just to name a few. It is very customizable, and as we will see, the router follows a regular lifecycle, and internally makes heavy use of tree-based data structures, as well as the RxJS library. But first, let's understand the difference between server-side routing, and client-side routing, as it will help us develop a better mental model of how Angular's router works."),(0,a.kt)("p",null,"For the first part of this chapter, consider the following minimal Angular application with routing. This is simple, but it will be enough to show the basics of routing. A more sophisticated example will be used later to show features such as lazy loading."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { RouterModule } from '@angular/router';\nimport { Component, Input } from '@angular/core';\n\n/**\n * Normally, this would be split over multiple files.\n * Everything is placed into one file here to make it\n * easier to read.\n */\n\n// Sample component for routing.\n// Displayed when we have routed to pathA\n@Component({\n  template: `<h1>This is Component A</h1>`\n})\nexport class ComponentA {}\n\n// Sample component for routing.\n// Displayed when we have routed to pathB\n@Component({\n  template: `<h1>This is Component B</h1>`\n})\nexport class ComponentB {}\n\n// Main compoment. Contains links for navigating to\n// pathA and pathB\n@Component({\n  selector: 'my-app',\n  template: `\n    <div>\n    <nav>\n      <h1>Navigation</h1>\n      <a routerLink=\"/pathA\">Path A</a>\n      &nbsp;\n      <a routerLink=\"/pathB\">Path B</a>\n    </nav>\n    <router-outlet></router-outlet>\n    </div>\n  `\n})\nexport class AppComponent {}\n\n// Table of static routes. This defintes all possible routes in our application.\n// When an object's `path` matches, its `component` is rendered using the \n// `<router-outlet>` directive\nconst ROUTES: Route[] = [\n  { path: 'path-a', component: ComponentA },\n  { path: 'path-b', component: ComponentB },\n];\n\n// Logs all router events to the console.\nconst optionsConfig = {\n  enableTracing: true\n};\n\n// Basic module setup\n@NgModule({\n  imports:      [ BrowserModule, RouterModule.forRoot(ROUTES, optionsConfig) ],\n  declarations: [ AppComponent, ComponentA, ComponentB ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n")),(0,a.kt)("p",null,"Nothing too exciting here. ",(0,a.kt)("inlineCode",{parentName:"p"},"RouterModule.forRoot")," takes an array containing our application's route (more on this later), as well as an optional configuration object which enables tracing. This means all router events will be logged to the console."),(0,a.kt)("h2",{id:"server-side-routing-and-client-side-routing"},"Server-Side Routing and Client-Side Routing"),(0,a.kt)("p",null,"Before we explore routing in Angular, it is worth noting the differences between client-side routing, which is what Angular's ",(0,a.kt)("inlineCode",{parentName:"p"},"RouterModule")," provides, and traditional server-side routing."),(0,a.kt)("p",null,"[TODO: Add diagram showing the difference]"),(0,a.kt)("p",null,"Consider the following two links. You might find #1 inside of a traditional HTML page that isn't using any modern Javascript framework. The second link is taken from out sample Angular application above (notice the ",(0,a.kt)("inlineCode",{parentName:"p"},"routerLink")," directive instead of the ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," attribute)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'// 1. Server-side routing example\n<a href="https://www.example.com/path-a">Path A</a>\n\n// 2. Client-side routing example (Angular)\n<a routerLink="/path-a">Path A</a>\n')),(0,a.kt)("h3",{id:"server-side-routing"},"Server-Side Routing"),(0,a.kt)("p",null,"Server-side routing is simple. When the user clicks on link #1, the browser detects that the link has been clicked. It then fetches the resource at the URL specified by href (",(0,a.kt)("inlineCode",{parentName:"p"},"https://www.example.com/path-a"),") using a GET request. The server at ",(0,a.kt)("inlineCode",{parentName:"p"},"www.example.com")," receives the request, checks its own internal routing table, and sends a response back to the browser containing the resource at ",(0,a.kt)("inlineCode",{parentName:"p"},"/path-a"),". Usually this response is an entirely new HTML page. Upon receiving this response, the browser refreshes the page, and displays the HTML document is has received from the server. "),(0,a.kt)("p",null,"With server-side routing, each time a navigation occurs, it involves a request to some server, and it results in an entirely new page being loaded. While server-side rendering can be great for things like web crawlers and search engine optimization, it tends to involve a lot of page refreshes, and can cause user experience to suffer."),(0,a.kt)("h3",{id:"client-side-routing-angular"},"Client-Side Routing (Angular)"),(0,a.kt)("p",null,"With client-side routing, things are very different. Notice in #2 that the anchor tag is using a ",(0,a.kt)("inlineCode",{parentName:"p"},"routerLink")," directive instead of a standard ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," attribute. This is so Angular can listen in and intercept the click instead of letting the browser make a GET request, as it did in the previous scenario. When this link is clicked, the ",(0,a.kt)("inlineCode",{parentName:"p"},"routerLink")," will tell Angular's router that the link has been clicked (this is also why updating the browser location directly will result in a full page refresh, since the Router doesn't intercept this). Instead of the browser making a request to a server for a new page, the router will instead check a list of user-defined routes to see if there are any entries for the ",(0,a.kt)("inlineCode",{parentName:"p"},"/path-a"),". If it finds one, the router will render the component(s) associated with that route using a ",(0,a.kt)("inlineCode",{parentName:"p"},"<router-outlet>")," directive, all without causing a single page refresh!"),(0,a.kt)("p",null,"We will go into much more detail in this guide about how the Angular router makes all of this possible. Just know for now that client-side routing is done entirely in the browser, and doesn't usually involve a page refresh (unless a user forces one by interacting with the browser location manually)."),(0,a.kt)("h2",{id:"defining-application-routes"},"Defining Application Routes"),(0,a.kt)("p",null,"When building an application, we usually know some if not all of our routes ahead of time. For example, an e-commerce application might have routes for ",(0,a.kt)("inlineCode",{parentName:"p"},"home"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"products"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"locations"),". Small applications may have only a handful of routes, whereas larger applications can have many routes. Regardless of how many routes an application has, we need some way of defining them."),(0,a.kt)("p",null,"In general, there are two approaches to defining routes in an application; ",(0,a.kt)("inlineCode",{parentName:"p"},"static")," routing and ",(0,a.kt)("inlineCode",{parentName:"p"},"dynamic")," routing. Static routing means that you define all of your application's routes in a configuration object before the app has loaded and before any rendering has taken place. With dynamic routing, routing takes place while your application is rendering. An example of this is version 4+ of the React-Router library. ","[give a simple example]",".\nSince Angular uses static routing, that will be the focus of this chapter."),(0,a.kt)("h3",{id:"static-routing-and-the-route-configuration-object"},"Static Routing, and the Route Configuration Object"),(0,a.kt)("p",null,"With static routing, you define all of your application's routes ahead of time, using an array of configuration objects. In our example above, we placed these configuration objects inside of an array called ",(0,a.kt)("inlineCode",{parentName:"p"},"ROUTES"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Table of static routes. This defintes all possible routes in our application.\n// When an object's `path` matches, its `component` is rendered using the \n// `<router-outlet>` directive\nconst ROUTES: Route[] = [\n  { path: 'path-a', component: ComponentA },\n  { path: 'path-b', component: ComponentB },\n];\n")),(0,a.kt)("p",null,"This defines two possible routes for our application, ",(0,a.kt)("inlineCode",{parentName:"p"},"path-a")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"path-b"),". When the browser location matches ",(0,a.kt)("inlineCode",{parentName:"p"},"path-a"),", Angular will render ",(0,a.kt)("inlineCode",{parentName:"p"},"ComponentA")," using our application's ",(0,a.kt)("inlineCode",{parentName:"p"},"<router-outlet>")," directives. Notice that this is an array of objects of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Route"),". A ",(0,a.kt)("inlineCode",{parentName:"p"},"Route")," specifies a pairing between a ",(0,a.kt)("inlineCode",{parentName:"p"},"path"),", and a ",(0,a.kt)("inlineCode",{parentName:"p"},"component"),". The full list of properties on the ",(0,a.kt)("inlineCode",{parentName:"p"},"Route")," interface is beyond the scope of this chapter, but a complete listing can be found on the official Angular site."),(0,a.kt)("h3",{id:"mental-model-1-a-tree-of-components"},"Mental Model 1: A Tree of Components"),(0,a.kt)("p",null,"If you are familiar with the Document Object Model (DOM), then you will know that an HTML document has an internal, JavaScript representation inside of the browser, where each element in the HTML document becomes a JavaScript object in the DOM. Since there is a hierarchy among nodes in an HTML document (due to nesting), these nodes are best represented by a tree."),(0,a.kt)("p",null,"Your Angular application is much the same, and a very useful mental model is to imagine your application as a tree of components. "),(0,a.kt)("h2",{id:"the-navigation-cycle"},"The Navigation Cycle"),(0,a.kt)("p",null,"The router follows a regular cycle of steps whenever a navigation occurs. It also has its own set of native events that are fired during navigation.\nLet's consider simple scenario where a user clicks on the following link inside of the appliation ",(0,a.kt)("inlineCode",{parentName:"p"},'<a routerLink="/about">about</a>'),"."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The link is clicked. Since this anchor tag is using the ",(0,a.kt)("inlineCode",{parentName:"li"},"routerLink")," directive instead of a regular ",(0,a.kt)("inlineCode",{parentName:"li"},"href")," attribute, Angular is able to intercept this event."),(0,a.kt)("li",{parentName:"ol"},"A ",(0,a.kt)("inlineCode",{parentName:"li"},"NavigationStart")," event is fired by the router, indicating the start of a navigation."),(0,a.kt)("li",{parentName:"ol"},"The router looks at the path ",(0,a.kt)("inlineCode",{parentName:"li"},"/about"),", and starts to traverse the router configuration object that was passed into ",(0,a.kt)("inlineCode",{parentName:"li"},"RouterModule.forRoot"),". It will check to see if any object in that tree of objects has a path property matching ",(0,a.kt)("inlineCode",{parentName:"li"},"/about"),". In the event that multiple objects contain this path, the first one to match wins."),(0,a.kt)("li",{parentName:"ol"},"The router will apply any redirects it finds in the configuration abject along the way. This is sometimes useful if your site has legacy URLs that you still want to support, but also want to redirect users to new URLs."),(0,a.kt)("li",{parentName:"ol"},"If the router finds a match inside of the routes configuration object, it dispatches a ",(0,a.kt)("inlineCode",{parentName:"li"},"RoutesRecognized")," event to signal that a match has been found."),(0,a.kt)("li",{parentName:"ol"},"It then applies any guard functions that are specificed for the matched route, and dispatches a ",(0,a.kt)("inlineCode",{parentName:"li"},"GuardsCheckStart")," event. If all of the guard functions pass, then the navigation continues, and a ",(0,a.kt)("inlineCode",{parentName:"li"},"GuardsCheckEnd")," event is dispatched."),(0,a.kt)("li",{parentName:"ol"},"Next, any route resolvers associated with this route are run. Route resolvers can be used to prefetch data for a route."),(0,a.kt)("li",{parentName:"ol"},"Assuming everything has been successful up to this point, the navigation is complete, and the ",(0,a.kt)("inlineCode",{parentName:"li"},"NavigationEnd")," event is fired.")),(0,a.kt)("p",null,"Navigations can be more complicated and nuanced than this example, but this is all we need."),(0,a.kt)("h2",{id:"the-role-of-the-router-outlet-directive"},"The role of the ",(0,a.kt)("inlineCode",{parentName:"h2"},"<router-outlet>")," directive"),(0,a.kt)("h2",{id:"route-configuration"},"Route configuration"),(0,a.kt)("p",null,"So far, we have seen what navigation is, and how ",(0,a.kt)("inlineCode",{parentName:"p"},"<router-outlet>")," directives are used to display routable content within our application. But, how does Angular actually know which components to associate with which routes? To answer this, we pass an array of route configuration objects into the RouterModule's ",(0,a.kt)("inlineCode",{parentName:"p"},"forRoot")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const ROUTES = [\n\n];\nRouterModule.forRoot(ROUTES);\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"<router-outlet>")," directive tells Angular which part(s) of our application should be managed by the router. For example, if you have some content that is present on every page of your application, such as a footer or navigation, then that content doesn't change, and doesn't necessarily need to go inside of a router-outlet. However, dynamic content will go inside."),(0,a.kt)("h2",{id:"route-guards"},"Route guards"),(0,a.kt)("h2",{id:"route-resolvers"},"Route resolvers"),(0,a.kt)("h2",{id:"router-events"},"Router events"),(0,a.kt)("h2",{id:"lazy-loading"},"Lazy loading"),(0,a.kt)("p",null,"We've seen how the router manages routing. It can also help make your applications more performant! If you structure your application code into distinct feature modules, you can take advantage of code-splitting and lazy loading. "),(0,a.kt)("h1",{id:"misc"},"Misc"),(0,a.kt)("h3",{id:"what-is-static-routing-how-does-it-differ-from-dynamic-routing"},"What is static routing? How does it differ from dynamic routing?"),(0,a.kt)("p",null,"If you are coming from React, you may be familiar with React's router. Prior to version 4, it also used static routing. Starting with version 4, it switched over to dynamic routing."),(0,a.kt)("h3",{id:"the-role-of-rxjs-in-routing"},"The Role of RxJS in Routing"),(0,a.kt)("p",null,"The developer-facing API of the Router doesn't require much knowledge of RxJS observables. However, just under the surface of the router, observables are everywhere. As with much of the Angular framework, observables provide a clean, composable way of moving and processing data."))}h.isMDXComponent=!0},3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=i.createContext({}),u=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=u(e.components);return i.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=u(n),h=o,g=d["".concat(s,".").concat(h)]||d[h]||c[h]||a;return n?i.createElement(g,r(r({ref:t},p),{},{components:n})):i.createElement(g,r({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var u=2;u<a;u++)r[u]=n[u];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);